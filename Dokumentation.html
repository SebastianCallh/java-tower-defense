<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Dokumentation</title>
    <style>
        #implementation-content {
        width: 400px;
        margin-left: auto;
        margin-right: auto;
        }
        #implementation-list {
        list-style-type:none;
        }
    </style>

</head>
<body>
<div id="implementation-content">
    <h1>Implementationer</h1>
    <ul id="implementation-list">
        <li>
            <h2>Theme</h2>
            En specifik klass för utseende valdes att använda för att andra objekt ej
            skulle behöva lusas ned med massa färger/sprites. Det leder också till stor
            modularitet och gör det lätt att byta utseende ifall man skulle vilja.
        </li>
        <li>
            <h2>Layout</h2>
            Layouten på nivåer skapades som en egen klass med privat konstruktor som endast skapas utifrån färdiga
            layout-filer i klartext som parsas till ett rutnät av faktiskta Tile-objekt. Detta för att se till att inget
            kan ändra i layouten medan spelet är igång och för att göra hanteringen av olika layouter lätta och modulär.
        </li>
        <li>
            <h2>Board</h2>
            Boardklassen agerar som spelplan där spelet faktiskt utspelar sig. Den är i grund och botten en
            samansättning av ett Theme-objekt som bestämmer hur saker ser ut, och ett Layout-objekt som bestämmer
            var saker och ting ligger, tämligen inspirerat av HTML/CSS-relationen. Utöver det kommer se.liu.ida.tddd78.towerdefense.Board också
            hålla reda på alla monster på banan och alla försvar man konstruerat.

        </li>
        <li>
            <h2>Factory</h2>
            En fabrik valdes för att frikoppla skapandet av modeller ifrån annan kod.
            Bidrar till modularisering och ifall vi i framtiden vill skapa modeller
            på flera olika ställen är detta väldigt användbart.
        </li>
        <li>
            <h2>Painter pattern 2015-02-14</h2>
            Vi slutar använda oss av GameObjectType för att bestämma hur ett GameObject ska målas och använder oss istället
            av olika singleton painters för varje typ av GameObject (Monster, Tower, etc) för att kunna separera kopplingen
            mellan hur ett GameObject är och hur det ritas ut (state hanteras av GameObject-implementationen och
            utseende hanteras av Theme). Genom att göra detta slipper GameObjectType användas för identifikation av
            typen i en sorts jättepainter som skulle hantera alla fall och specifika painters används istället, vilket
            bland annat underlättar när utritningen behöver göras mer avancerad.
        </li>
        <li>
            <h2>GameObjects</h2>
            Vi använder en egen klass för att hålla koll på alla gameobjects i board. Den håller koll på vilken typ
            av objekt allt är men tillåter oss också att iterera över alla objekt på brädan. Unmodifiablelist används
            för att försäkra oss om att ingen annan klass ändrar i listorna.
        </li>
        <li>
            <h2>Pathfinder</h2>
            En statis pathfinderklass används för att en gång vid start breath-first-söka igenom den navigerbara biten
            av kartan och spara närmsta väg tillbaka. Senare används den för att bestämma var monstren skall röra sig.
        </li>
        <li>
            <h2>IMPLEMENTATION</h2>
            MOTIVATION
        </li>
    </ul>
    <!--BOILERPLATE
        <li>
            <h2>IMPLEMENTATION</h2>
            MOTIVATION
        </li>
    -->
</div>
</body>
</html>